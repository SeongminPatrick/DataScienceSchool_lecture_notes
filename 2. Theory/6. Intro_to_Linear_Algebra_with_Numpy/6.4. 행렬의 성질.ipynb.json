{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {
    "school_cell_uuid": "01916f7e1d69497b81c751bb830992d6"
   },
   "source": [
    "# 행렬의 성질"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "school_cell_uuid": "87f78070f97b4aacae02821c45bde239"
   },
   "source": [
    "##  행렬의 부호"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "school_cell_uuid": "5ab47f01ef6d4af6a182ddf90d6104fd"
   },
   "source": [
    "행렬은 여러 개의 숫자로 이루어져 있으므로 행렬 전체의 부호는 정의하기 어렵다. 하지만 행렬에서도 실수의 부호와 비슷한 특성이 존재한다. 바로 행렬의 양-한정(positive definite) 특성이다.\n",
    "\n",
    "영 벡터가 아닌 모든 벡터 $x$ 에 대해 다음 부등식이 성립하면 행렬 $A$ 가 **양-한정(positive definite)**이라고 한다.\n",
    "\n",
    "$$ x^T A x > 0 $$\n",
    "\n",
    "만약 이 식이 등호를 포함한다면 **양-반한정(positive semi-definite)**이라고 한다.\n",
    "\n",
    "$$ x^T A x \\geq 0 $$"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "school_cell_uuid": "9b17a0f7d29c4eafaf2bb2f1ebc5de30"
   },
   "source": [
    "예를 들어 단위 행렬은 양-한정이다. 벡터 $x$는 영 벡터가 아니라는 점에 주의한다.\n",
    "\n",
    "$$ x^TI x = \n",
    "\\begin{bmatrix}\n",
    "x_1 & x_2 & \\cdots & x_N\n",
    "\\end{bmatrix}\n",
    "\\begin{bmatrix}\n",
    "1&0&\\cdots&0\\\\\n",
    "0&1&\\cdots&0\\\\\n",
    "\\vdots&\\vdots&\\ddots&\\vdots\\\\\n",
    "0&0&\\cdots&1\\\\\n",
    "\\end{bmatrix}\n",
    "\\begin{bmatrix}\n",
    "x_1 \\\\ x_2 \\\\ \\vdots \\\\ x_N\n",
    "\\end{bmatrix}\n",
    "= x_1^2 + x_2^2 + \\cdots + x_N^2 > 0 \n",
    "$$\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "school_cell_uuid": "8524015d69fc473da43aa48e5c2695e7"
   },
   "source": [
    "다음과 같은 행렬도 양-한정이다.\n",
    "\n",
    "$$ A = \\begin{bmatrix} 2&-1&0\\\\-1&2&-1\\\\0&-1&2 \\end{bmatrix} $$\n",
    "\n",
    "이는 다음과 같이 증명할 수 있다.\n",
    "\n",
    "모든 벡터 $x^T = [x_1 \\; x_2 \\; x_3]$에 대해 \n",
    "\n",
    "$$ \n",
    "\\begin{align} \n",
    "x^TA x \n",
    "&= \\begin{bmatrix} x_1 & x_2 & x_3 \\end{bmatrix} \\begin{bmatrix} 2&-1&0\\\\-1&2&-1\\\\0&-1&2 \\end{bmatrix}  \\begin{bmatrix} x_1\\\\x_2\\\\x_3 \\end{bmatrix} \\\\\n",
    "&= \\begin{bmatrix} (2x_1-x_2)&(-x_1+2x_2-x_3)&(-x_2+2x_3) \\end{bmatrix} \\begin{bmatrix} x_1\\\\x_2\\\\x_3 \\end{bmatrix} \\\\\n",
    "&= 2{x_1}^2 - 2x_1x_2 + 2{x_2}^2 - 2x_2x_3 + 2{x_3}^2 \\\\\n",
    "&= {x_1}^2+(x_1 - x_2)^{2} + (x_2 - x_3)^{2}+{x_3}^2 \n",
    "\\end{align}\n",
    "$$\n",
    "\n",
    "이 성립한다. 그리고 이 값은 제곱의 합으로 이루어져 있기 때문에 $x_1 = x_2 = x_3 = 0$ 인 경우를 제외하고는 항상 0보다 크다.\n",
    "\n",
    "$$ {x_1}^2+(x_1 - x_2)^{2} + (x_2 - x_3)^{2}+{x_3}^2  > 0 $$"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "bootstrap": {
     "panel": {
      "class": "panel-default"
     }
    },
    "school_cell_uuid": "7fc6a53d8bcf408382f1cf2c339162bf"
   },
   "source": [
    "#### 연습 문제 1\n",
    "\n",
    "다음 행렬을 양-한정, 양-반한정 혹은 아무것도 해당되지 않는지 판단하라.\n",
    "\n",
    "$$ \\begin{bmatrix} 1 & 1 \\\\ 1 & 1 \\end{bmatrix} $$"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "school_cell_uuid": "06074fb67981420096862e0012f22f5d"
   },
   "source": [
    "## 행렬의 크기"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "school_cell_uuid": "c52b225e5428461f99f45cdc196ba062"
   },
   "source": [
    "부호와 마찬가지로 행렬의 크기를 정의하는 것도 어렵다. 하지만 하나의 행렬에 대해 하나의 실수를 대응시키는 **놈(norm)**, **대각 성분(trace)**, **행렬식(determinant)**이란 연산은 행렬의 크기와 비슷한 의미를 가진다."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "school_cell_uuid": "b0e1102eff274b52a4d2766601e2fb20"
   },
   "source": [
    "### 행렬 놈"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "school_cell_uuid": "829b7c3c2f1e41698fb0d7933303fc06"
   },
   "source": [
    "행렬의 **놈(norm)**은 행렬 $A$에 대해 다음과 같이 정의되는 숫자이다. 보통 $\\Vert A \\Vert_L$ 로 표기한다. $L$는 1, 2 또는 무한대($\\infty$)이다. 이 식에서 $a_{ij}$는 행렬 $A$의 $i$번째 행, $j$번째 열의 원소이다.\n",
    "\n",
    "$$ \\Vert A \\Vert_L = \\left( \\sum_{i=1}^M \\sum_{j=1}^N |a_{ij}|^L \\right)^{1/L} $$\n",
    "\n",
    "$L=1$이면 L1놈, $L=2$이면 L2놈이라고 부른다.\n",
    "이 중 $L=2$인 경우가 많이 쓰이므로 $L$ 값 표시가 없는 경우는 $L=2$인 놈이라고 생각하면 된다.\n",
    "이 경우에는 **프로베니우스 놈(Frobenius norm)**이라고 불리며 $\\Vert A \\Vert_F$이라고 표기하기도 한다.\n",
    "\n",
    "$$ \\Vert A \\Vert = \\Vert A \\Vert_F = \\sqrt{\\sum_{i=1}^M \\sum_{j=1}^N a_{ij}^2} $$"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "school_cell_uuid": "71352c648ca14a44ad8f8c1ce444a5a2"
   },
   "source": [
    "놈은 모든 크기의 행렬에 대해서 정의할 수 있으므로 벡터에 대해서도 정의할 수 있다. 벡터의 놈의 제곱은 그 벡터의 제곱합과 같다.\n",
    "\n",
    "$$ \\Vert x \\Vert^2 = \\sum_{i=1}^N x_{i}^2 = x^Tx$$\n",
    "\n",
    "따라서 벡터의 제곱합을 최소화(가장 작게 만드는 것)하는 것은 놈을 최소화하는 것과 같다."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "school_cell_uuid": "2bf13d2eb8a74d33971496447e92c94d"
   },
   "source": [
    "NumPy에서는 linalg 서브패키지의 `norm` 명령으로 행렬의 놈을 계산할 수 있다. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {
    "school_cell_uuid": "902fbfabbf434200865b213510ef4892"
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([[-4, -3, -2],\n",
       "       [-1,  0,  1],\n",
       "       [ 2,  3,  4]])"
      ]
     },
     "execution_count": 1,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "A = (np.arange(9) - 4).reshape((3, 3))\n",
    "A"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {
    "school_cell_uuid": "8e2fb2cd0c2b4cfe8af5d464625c32ae"
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "7.745966692414834"
      ]
     },
     "execution_count": 2,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "np.linalg.norm(A)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "school_cell_uuid": "452701e5ef804f4db62872fe7af559ec"
   },
   "source": [
    "### 대각 성분"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "school_cell_uuid": "6db9f620dffa4698b5e6736869df7223"
   },
   "source": [
    "**대각 성분(trace)**은 정방 행렬에 대해서만 정의되며 다음과 같이 대각 원소들의 합으로 계산된다.\n",
    "\n",
    "$$ \\operatorname{tr}(A) = a_{11} + a_{22} + \\dots + a_{NN}=\\sum_{i=1}^{N} a_{ii} $$"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "school_cell_uuid": "dab6beeefafb454eae7e3624fffec2cd"
   },
   "source": [
    "대각 성분은 다음과 같은 성질을 지닌다. 아래의 식에서 $c$는 스칼라이고 $A, B, C$는 행렬이다.\n",
    "\n",
    "$$ \\text{tr} (cA) = c\\;\\text{tr} (A) $$\n",
    "\n",
    "$$ \\text{tr} (A^T) = \\text{tr} (A) $$\n",
    "\n",
    "$$ \\text{tr} (A + B) = \\text{tr} (A) + \\text{tr} (B)$$\n",
    "\n",
    "$$ \\text{tr} (AB) = \\text{tr} (BA) $$\n",
    "\n",
    "$$ \\text{tr} (ABC) = \\text{tr} (BCA) = \\text{tr} (CAB) $$\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "school_cell_uuid": "aae5a7093e4f49c89db2ee35649e706f"
   },
   "source": [
    "특히 마지막 두 수식은 **트레이스 트릭(trace trick)** 이라고 하여 이차 형식(quadratic form)의 미분을 구하는데 유용하게 사용된다. 이 두 수식에서는 $A, B, C$가 각각 정방행렬일 필요는 없고 대각성분을 구하는 행렬이 정방행렬이 되기만 하면 된다.\n",
    "\n",
    "이차 형식의 트레이스 트릭 공식은 다음과 같다.\n",
    "\n",
    "$$ x^TAx = \\text{tr}(x^TAx) = \\text{tr}(Axx^T)  = \\text{tr}(xx^TA) $$\n",
    "\n",
    "이 식은 원래의 트레이스 트릭 수식의 $A$, $B$, $C$ 에 각각 $x^T$, $A$, $x$를 대입한 것이다. 이차 형식은 스칼라 값이기 때문에 대각 성분을 취해도 원래의 값과 같다."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "school_cell_uuid": "6743c07fc7b3448b87301ed07700ff31"
   },
   "source": [
    "NumPy에서는 linalg 서브패키지의 `trace` 명령으로 trace를 계산할 수 있다. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {
    "school_cell_uuid": "ba74f2d8ff1f4017b574685f2d3f2a33"
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "3.0"
      ]
     },
     "execution_count": 3,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "np.trace(np.eye(3))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "bootstrap": {
     "panel": {
      "class": "panel-default"
     }
    },
    "school_cell_uuid": "7fc6a53d8bcf408382f1cf2c339162bf"
   },
   "source": [
    "#### 연습 문제 2\n",
    "\n",
    "$x$, $A$가 각각 크기가 2 인 벡터, 크기가 2x2 인 정방 행렬일 때 이차 형식의 트레이스 트릭이 성립함을 보인다."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "school_cell_uuid": "e792da6449ed4ea3b25d4a33f0662255"
   },
   "source": [
    "### 행렬식"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "school_cell_uuid": "1796b8a75d894262938db99a38cbae39"
   },
   "source": [
    "정방 행렬 $A$의 **행렬식(determinant)**은 $\\text{det}(A)$라는 기호 또는 $|A|$라는 기호로 표기한다."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "school_cell_uuid": "4fcf674c22f2463fa4d8b13359350dfa"
   },
   "source": [
    "\n",
    "행렬식은 다음과 같이 코팩터 확장(cofactor expansion) 이라고 불리는 재귀적인 방법으로 정의된다. \n",
    "\n",
    "$$ \\det(A) = \\sum_{i=1}^N \\left\\{ (-1)^{i+j_0}M_{i,j_0} \\right\\} a_{i,j_0} = \\sum_{j=1}^N \\left\\{ (-1)^{i_0+j} M_{i_0,j} \\right\\} a_{i_0,j}  $$\n",
    "\n",
    "이 식에서 $a_{i,j}$는 $A$의 $i$행, $j$열 원소이다. 즉, 행렬에서 임의의 행 $i_0$ 하나를 선택하거나 임의의 열 $j_0$ 하나를 선택한 다음 이 값에 가중치 $(-1)^{i+j_0}M_{i,j_0}$ 또는 $ (-1)^{i_0+j} M_{i_0,j}$를 곱하여 더한 것이다. \n",
    "\n",
    "가중치로 사용된 $M_{i,j}$은 마이너(minor)라고 하며 정방 행렬 $A$ 에서 $i$행과 $j$열을 지워서 얻어진 (원래의 행렬보다 크기가 1만큼 작은) 행렬의 행렬식이다. 마이너 값도 행렬식이므로 마찬가지로 위의 식을 이용하여 구해야 한다. 이렇게 점점 작은 행렬의 행렬식을 구해야 하기 때문에 이 식을 재귀적(recursive)이라고 한다.\n",
    "\n",
    "마이너에 $(-1)^{i+j}$를 곱한 값을 코팩터(cofactor) $C_{i,j}$ 라고 한다.\n",
    "코팩터를 사용하여 위 식을 다시 표현하면 다음과 같다.\n",
    "\n",
    "$$  \\det(A) = \\sum_{i=1}^N C_{i,j_0} a_{i,j_0}  =  \\sum_{j=1}^N C_{i_0,j} a_{i_0,j}   $$"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "school_cell_uuid": "08971dec35fa42929b5c6bdd980e068b"
   },
   "source": [
    "예를 들어 다음과 같은 행렬을 생각해보자.\n",
    "\n",
    "$$\n",
    "\\begin{bmatrix}1&2&3\\\\4&5&6\\\\7&8&9\\end{bmatrix}\n",
    "$$\n",
    "\n",
    "여기에서 임의의 행 또는 열을 선택한다. 행이든 열이든 상관없다. "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "school_cell_uuid": "089e5f7afea34dd785156bc62b06fd0e"
   },
   "source": [
    "만약 첫번째 열을 선택했다고 하면 이 행렬의 행렬식은 다음과 같이 계산한다.\n",
    "\n",
    "$$ \n",
    "\\begin{eqnarray}\n",
    "\\det(A) \n",
    "&=& \\left\\{ (-1)^{1+1}M_{1,1} \\right\\} a_{1,1} +  \\left\\{ (-1)^{2+1}M_{2,1} \\right\\} a_{2,1} +  \\left\\{ (-1)^{3+1}M_{3,1} \\right\\} a_{3,1} \\\\\n",
    "&=& M_{1,1} a_{1,1} - M_{2,1} a_{2,1} + M_{3,1} a_{3,1} \\\\\n",
    "&=& M_{1,1} -  M_{2,1} \\times 4 + M_{3,1} \\times 7\n",
    "\\end{eqnarray}\n",
    "$$\n",
    "\n",
    "이 때 마이너 값 $M_{1,1}$, $M_{2,1}$, $M_{3,1}$는 각각 다음과 같은 행렬의 행렬식이다."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "school_cell_uuid": "96875400783745449ce6887bbb61056a"
   },
   "source": [
    "$M_{1,1}$은 원래의 행렬에서 $1$번째 행과 $1$번째 열을 지워서 만들어진 행렬의 행렬식이다.\n",
    "\n",
    "$$ M_{1,1} = \\det \\left( \\begin{bmatrix}5&6\\\\8&9\\end{bmatrix} \\right) $$"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "school_cell_uuid": "f020c48ece6d4ef9a42442fb3e071546"
   },
   "source": [
    "$M_{2,1}$은 원래의 행렬에서 $2$번째 행과 $1$번째 열을 지워서 만들어진 행렬의 행렬식이다.\n",
    "\n",
    "$$ M_{2,1} = \\det \\left( \\begin{bmatrix}2&3\\\\8&9\\end{bmatrix} \\right) $$"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "school_cell_uuid": "0cc348973e4c4acca0c31a9396d8a1c5"
   },
   "source": [
    "$M_{3,1}$은 원래의 행렬에서 $3$번째 행과 $1$번째 열을 지워서 만들어진 행렬의 행렬식이다.\n",
    "\n",
    "$$ M_{3,1} = \\det \\left( \\begin{bmatrix}2&3\\\\5&6\\end{bmatrix} \\right) $$"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "school_cell_uuid": "60ddf3595d1e4d5ab0d3aab92f55da37"
   },
   "source": [
    "이 마이너 값 $M_{1,1}$, $M_{2,1}$, $M_{3,1}$는 마찬가지로 코팩터 공식을 이용해서 계산할 수 있다. 이렇게 재귀적으로 계산하다 보면 결국 크기가 스칼라인 경우에 도달하게 된다."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "school_cell_uuid": "2c900c10d47c4c2f9596a68bde64885a"
   },
   "source": [
    "이 때 어떤 행을 선택하든 또는 어떤 열을 선택하는 최종적으로 계산된 행렬식의 값은 동일한 값을 가진다."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "school_cell_uuid": "c424dc5de05b447b89bbb2cbe88af993"
   },
   "source": [
    "위의 정의를 사용하면 크기가 1, 2, 3인 정방 행렬의 행렬식은 다음과 같아진다.\n",
    "\n",
    "* 1×1 행렬의 행렬식\n",
    "\n",
    "$$\\det \\left( \\begin{bmatrix}a\\end{bmatrix} \\right) =a$$\n",
    "\n",
    "* 2×2 행렬의 행렬식\n",
    "$$\\det \\left( \\begin{bmatrix}a&b\\\\c&d\\end{bmatrix} \\right) =ad-bc$$\n",
    "\n",
    "* 3×3 행렬의 행렬식\n",
    "$$\\det \\left( \\begin{bmatrix}a&b&c\\\\d&e&f\\\\g&h&i\\end{bmatrix} \\right) =aei+bfg+cdh-ceg-bdi-afh$$\n",
    " "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "school_cell_uuid": "6a26440495474669979e33688da94eac"
   },
   "source": [
    "NumPy에서는 linalg 서브패키지의 `det` 명령으로 행렬식을 계산할 수 있다. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {
    "school_cell_uuid": "55a6814c2ce34fd99fa08299c82f2229"
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([[1, 2],\n",
       "       [3, 4]])"
      ]
     },
     "execution_count": 4,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "A = np.array([[1, 2], [3, 4]])\n",
    "A"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {
    "school_cell_uuid": "6ca77b57ac2b49e89922c9c40f88a88d"
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "-2.0000000000000004"
      ]
     },
     "execution_count": 5,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "np.linalg.det(A)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "bootstrap": {
     "panel": {
      "class": "panel-default"
     }
    },
    "school_cell_uuid": "7fc6a53d8bcf408382f1cf2c339162bf"
   },
   "source": [
    "#### 연습 문제 3\n",
    "\n",
    "행렬식의 정의를 사용하여 2x2 행렬과 3x3 행렬의 행렬식이 위와 같아짐을 보인다."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "school_cell_uuid": "8595cdfbccdb4dd4a2a55c72213edc32"
   },
   "source": [
    "행렬식은 다음과 같은 성질을 만족한다."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "school_cell_uuid": "38ef5c0690544a73957031aa519d0827"
   },
   "source": [
    "* 전치행렬의 행렬식은 원래의 행렬의 행렬식과 같다. \n",
    "\n",
    "$$ \\det(A^{T}) = \\det(A) $$"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "school_cell_uuid": "02d72ee8a7774182adcbcda14d111e47"
   },
   "source": [
    "* 단위 행렬의 행렬식은 1이다.\n",
    "\n",
    "$$\\det(I) = 1$$"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "school_cell_uuid": "b5aedd1cd5ab43b9b5a8ae11f31e5c60"
   },
   "source": [
    "* 두 행렬의 곱의 행렬식은 각 행렬의 행렬식의 곱과 같다. \n",
    "$$\\det(AB) = \\det(A)\\det(B)$$"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "school_cell_uuid": "4b5352dcd8f14d80bca818bff2c4bc4b"
   },
   "source": [
    "* 역행렬의 행렬식은 원래의 행렬의  행렬식의 역수와 같다. (역행렬의 정의에 대해서는 곧 설명한다.)\n",
    "\n",
    "$$ \\det(A^{-1}) = \\dfrac{1}{\\det(A)} $$"
   ]
  }
 ],
 "metadata": {
  "celltoolbar": "Edit Metadata",
  "kernelspec": {
   "display_name": "Python 2",
   "language": "python",
   "name": "python2"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 2
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython2",
   "version": "2.7.13"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 1
}